float tspDynamicProgramming(Graph& graph, Station* src, Station* dest, set<Vertex<Station>>& visited, vector<vector<float>>& dp)
{
    // Base case: If the current station is the destination, return the distance from the destination to the starting station
    if (src == dest)
        return graph.getWeight(dest, src);

    // Check if the solution has already been computed
    if (dp[src->getId()][visited.size()] != -1.0)
        return dp[src->getId()][visited.size()];

    // Mark the current station as visited
    visited.insert(graph.getVertex(src->getId()));

    // Initialize the shortest distance with a large value
    float shortestDistance = numeric_limits<float>::max();

    // Iterate over all neighbors of the current station
    for (const auto& neighbor : graph.getNeighbors(src))
    {
        Station* nextStation = neighbor->findNetwork.getCodeB();

        // Skip if the neighbor is already visited
        if (visited.count(graph.getVertex(nextStation->getId())) > 0)
            continue;

        // Calculate the distance from the current station to the next station
        float distance = neighbor->getWeight();

        // Recursive call to calculate the shortest distance by visiting the next station
        float remainingDistance = tspDynamicProgramming(graph, nextStation, dest, visited, dp);

        // Update the shortest distance if the total distance is smaller
        shortestDistance = min(shortestDistance, distance + remainingDistance);
    }

    // Remove the current station from the visited set
    visited.erase(graph.getVertex(src->getId()));

    // Memoize the computed shortest distance
    dp[src->getId()][visited.size()] = shortestDistance;

    return shortestDistance;
}